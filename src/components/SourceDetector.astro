---
/**
 * Main source detector component.
 * Combines input section and result card with client-side interactivity.
 */
import InputSection from "./InputSection.astro";
import ResultCard from "./ResultCard.astro";
---

<source-detector class="source-detector">
  <div class="card detector-card">
    <InputSection />
    <ResultCard />
  </div>
</source-detector>

<script>
  import {
    detectSource,
    formatConfidence,
    type UTMParameters,
    type DetectionResult,
  } from "../scripts/source-detector";

  class SourceDetectorElement extends HTMLElement {
    private urlInput: HTMLInputElement | null = null;
    private utmInputs: Map<keyof UTMParameters, HTMLInputElement> = new Map();
    private analyzeButton: HTMLButtonElement | null = null;
    private clearButton: HTMLButtonElement | null = null;
    private tabButtons: NodeListOf<HTMLButtonElement> | null = null;
    private tabPanels: NodeListOf<HTMLElement> | null = null;
    private resultSection: HTMLElement | null = null;
    private activeTab: "url" | "utm" = "url";

    connectedCallback() {
      this.initializeElements();
      this.attachEventListeners();
    }

    private initializeElements() {
      this.urlInput = this.querySelector("#url-input");
      this.utmInputs.set(
        "utm_source",
        this.querySelector("#utm-source") as HTMLInputElement,
      );
      this.utmInputs.set(
        "utm_medium",
        this.querySelector("#utm-medium") as HTMLInputElement,
      );
      this.utmInputs.set(
        "utm_campaign",
        this.querySelector("#utm-campaign") as HTMLInputElement,
      );
      this.utmInputs.set(
        "utm_content",
        this.querySelector("#utm-content") as HTMLInputElement,
      );
      this.utmInputs.set(
        "utm_term",
        this.querySelector("#utm-term") as HTMLInputElement,
      );

      this.analyzeButton = this.querySelector("#analyze-button");
      this.clearButton = this.querySelector("#clear-button");
      this.tabButtons = this.querySelectorAll(".tab-button");
      this.tabPanels = this.querySelectorAll(".tab-panel");
      this.resultSection = this.querySelector("#result-section");
    }

    private attachEventListeners() {
      // Handle form submission
      const form = this.querySelector(".input-form");
      form?.addEventListener("submit", (event) => {
        event.preventDefault();
        this.handleAnalyze();
      });

      // Handle form reset
      form?.addEventListener("reset", () => {
        // Delay to allow native reset to complete
        setTimeout(() => this.handleClear(), 0);
      });

      this.tabButtons?.forEach((button) => {
        button.addEventListener("click", () => {
          const tab = button.dataset.tab as "url" | "utm";
          this.switchTab(tab);
        });
      });

      // Copy recommendation button
      const copyButton = this.querySelector("#copy-recommendation");
      copyButton?.addEventListener("click", () => this.copyRecommendation());
    }

    private switchTab(tab: "url" | "utm") {
      this.activeTab = tab;

      this.tabButtons?.forEach((button) => {
        const isActive = button.dataset.tab === tab;
        button.classList.toggle("active", isActive);
        button.setAttribute("aria-selected", isActive.toString());
      });

      this.tabPanels?.forEach((panel) => {
        const isActive = panel.dataset.panel === tab;
        panel.classList.toggle("active", isActive);
        panel.hidden = !isActive;
      });
    }

    private getInputValues(): {
      url: string;
      utmParams: Partial<UTMParameters>;
    } {
      const url = this.urlInput?.value.trim() || "";
      const utmParams: Partial<UTMParameters> = {};

      this.utmInputs.forEach((input, key) => {
        const value = input?.value.trim();
        if (value) {
          utmParams[key] = value;
        }
      });

      return { url, utmParams };
    }

    private handleAnalyze() {
      const { url, utmParams } = this.getInputValues();

      // Determine what to analyze based on active tab
      let urlToAnalyze: string | undefined;
      let paramsToAnalyze: Partial<UTMParameters> | undefined;

      if (this.activeTab === "url") {
        urlToAnalyze = url || undefined;
      } else {
        paramsToAnalyze =
          Object.keys(utmParams).length > 0 ? utmParams : undefined;
      }

      // Validate input
      if (!urlToAnalyze && !paramsToAnalyze) {
        this.showError("Please enter a URL or UTM parameters to analyze.");
        return;
      }

      // Perform detection
      const result = detectSource(urlToAnalyze, paramsToAnalyze);
      this.displayResult(result);
    }

    private handleClear() {
      if (this.urlInput) {
        this.urlInput.value = "";
      }

      this.utmInputs.forEach((input) => {
        if (input) {
          input.value = "";
        }
      });

      if (this.resultSection) {
        this.resultSection.hidden = true;
      }
    }

    private showError(message: string) {
      // Simple error display using the result section
      const result: DetectionResult = {
        source: "",
        sourceDisplayName: "Error",
        medium: "",
        mediumDisplayName: "",
        isPaid: false,
        confidence: 0,
        confidenceLevel: "low",
        icon: "⚠️",
        recommendation: message,
        matchedBrand: null,
        detectedClickIds: [],
        signals: [],
        rawUtmParams: {},
      };
      this.displayResult(result);
    }

    private displayResult(result: DetectionResult) {
      if (!this.resultSection) return;

      // Update result elements
      const iconEl = this.querySelector("#result-icon");
      const sourceEl = this.querySelector("#result-source");
      const mediumEl = this.querySelector("#result-medium");
      const confidenceBadge = this.querySelector("#confidence-badge");
      const confidenceValue = this.querySelector("#confidence-value");
      const recommendationText = this.querySelector("#recommendation-text");
      const paidIndicator = this.querySelector("#paid-indicator");
      const signalsList = this.querySelector("#signals-list");
      const signalsSection = this.querySelector("#signals-section");
      const utmTableBody = this.querySelector("#utm-table-body");
      const utmDetails = this.querySelector("#utm-details");
      const clickIdList = this.querySelector("#clickid-list");
      const clickIdDetails = this.querySelector("#clickid-details");

      if (iconEl) iconEl.textContent = result.icon;
      if (sourceEl) sourceEl.textContent = result.sourceDisplayName;
      if (mediumEl)
        mediumEl.textContent = result.mediumDisplayName || "Unknown medium";

      if (confidenceBadge) {
        confidenceBadge.className = `confidence-badge ${result.confidenceLevel}`;
      }
      if (confidenceValue)
        confidenceValue.textContent = formatConfidence(result.confidence);
      if (recommendationText)
        recommendationText.textContent = result.recommendation;

      // Paid indicator
      if (paidIndicator) {
        (paidIndicator as HTMLElement).hidden = !result.isPaid;
      }

      // Signals list
      if (signalsList && signalsSection) {
        signalsList.innerHTML = "";
        if (result.signals.length > 0) {
          (signalsSection as HTMLElement).hidden = false;
          result.signals.forEach((signal) => {
            const li = document.createElement("li");
            li.textContent = signal.description;
            signalsList.appendChild(li);
          });
        } else {
          (signalsSection as HTMLElement).hidden = true;
        }
      }

      // UTM parameters table
      if (utmTableBody && utmDetails) {
        utmTableBody.innerHTML = "";
        const utmKeys = [
          "utm_source",
          "utm_medium",
          "utm_campaign",
          "utm_content",
          "utm_term",
        ] as const;
        let hasUtmParams = false;

        utmKeys.forEach((key) => {
          const value = result.rawUtmParams[key];
          if (value) {
            hasUtmParams = true;
            const row = document.createElement("tr");
            row.innerHTML = `<td>${key}</td><td>${this.escapeHtml(value)}</td>`;
            utmTableBody.appendChild(row);
          }
        });

        (utmDetails as HTMLElement).hidden = !hasUtmParams;
      }

      // Click IDs list
      if (clickIdList && clickIdDetails) {
        clickIdList.innerHTML = "";
        if (result.detectedClickIds.length > 0) {
          (clickIdDetails as HTMLElement).hidden = false;
          result.detectedClickIds.forEach((clickId) => {
            const li = document.createElement("li");
            li.innerHTML = `<strong>${this.escapeHtml(clickId.param)}</strong>: ${clickId.definition.displayName}`;
            clickIdList.appendChild(li);
          });
        } else {
          (clickIdDetails as HTMLElement).hidden = true;
        }
      }

      // Show result section
      this.resultSection.hidden = false;
      this.resultSection.scrollIntoView({
        behavior: "smooth",
        block: "nearest",
      });
    }

    private escapeHtml(text: string): string {
      const div = document.createElement("div");
      div.textContent = text;
      return div.innerHTML;
    }

    private async copyRecommendation() {
      const recommendationText = this.querySelector("#recommendation-text");
      const copyButton = this.querySelector("#copy-recommendation");

      if (!recommendationText || !copyButton) return;

      const text = recommendationText.textContent || "";

      try {
        await navigator.clipboard.writeText(text);
        copyButton.classList.add("copied");

        setTimeout(() => {
          copyButton.classList.remove("copied");
        }, 2000);
      } catch (error) {
        console.error("Failed to copy text:", error);
      }
    }
  }

  customElements.define("source-detector", SourceDetectorElement);
</script>

<style>
  .source-detector {
    display: block;
    width: 100%;
    max-width: var(--max-width-content);
    margin: 0 auto;
  }

  .detector-card {
    padding: var(--spacing-lg);
  }

  @media (min-width: 768px) {
    .detector-card {
      padding: var(--spacing-2xl);
    }
  }
</style>
